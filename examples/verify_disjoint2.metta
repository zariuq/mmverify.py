!(bind! &stack (new-space))
!(bind! &kb (new-space))
!(bind! &sp (new-state -1))
(: matchc (-> hyperon::space::DynSpace Atom Atom %Undefined%))
(= (matchc $space $pattern $query) (collapse (match $space $pattern $query)))
(= (empty-space $space) (matchc $space $atom (remove-atom $space $atom)))
(= (remove-pattern $space $pattern) (let $pattern (match $space $pattern $pattern) (remove-atom $space $pattern)))
(= (remove-patternc $space $pattern) (collapse (let $pattern (match $space $pattern $pattern) (remove-atom $space $pattern))))
(= (remove_from_stack $stack_ptr $stack_len) (if (> $stack_len $stack_ptr) (let () (remove-pattern &stack ( (Num $stack_ptr) $s )) (remove_from_stack (+ 1 $stack_ptr) $stack_len)) ()))
(: match-atom (-> Expression Atom Atom %Undefined$))
(= (match-atom $expr $pattern $rewrite) (if-decons-expr $expr $head $tail (let $pattern $head $rewrite) (empty)))
(= (match-atom $expr $pattern $rewrite) (if-decons-expr $expr $head $tail (match-atom $tail $pattern $rewrite) (empty)))
(: match-atom' (-> Expression Atom Atom %Undefined$))
(= (match-atom' $expr $pattern $rewrite) (case (match-atom $expr $pattern $rewrite) ( (Empty () ) ( $q $q ) )))
(: match-atom'' (-> Expression Atom Atom Atom %Undefined$))
(= (match-atom'' $expr $pattern $rewrite $Empty) (case (match-atom $expr $pattern $rewrite) ( (Empty $Empty) ( $q $q ) )))
(= (update-atom $space $atom $update_pattern) (match $space $atom (let () (add-atom $space $update_pattern) (remove-atom $space $atom))))
(= (adjust-state-additive $state $delta) (chain (get-state $state) $current (change-state! $state (+ $current $delta))))
(: match' (-> (List Atom) $a $a $a))
(= (match' Nil $pattern $rewrite) (empty))
(= (match' (Cons $head $tail) $pattern $rewrite) (let $pattern $head $rewrite))
(= (match' (Cons $head $tail) $pattern $rewrite) (match' $tail $pattern $rewrite))
(= (to-list $expr) (if (== $expr ()) Nil (Cons (car-atom $expr) (to-list (cdr-atom $expr)))))
(= (to-list' $expr $tail) (if (== $expr ()) $tail (Cons (car-atom $expr) (to-list' (cdr-atom $expr) $tail))))
(= (flatten-list Nil) Nil)
(= (flatten-list (Cons $head $tail)) (case (get-metatype $head) ((Expression (to-list' $head (flatten-list $tail))) ($_ (Cons $head (flatten-list $tail))))))
(= (from-list Nil) ())
(= (from-list (Cons $head $tail)) (let $tail-list (from-list $tail) (cons-atom $head $tail-list)))
(= (flatten-expr $expr) (from-list (flatten-list (to-list $expr))))
(= (append Nil $list) $list)
(= (append (Cons $head $tail) $list) (Cons $head (append $tail $list)))
(= (filter' Nil $predicate) Nil)
(= (filter' (Cons $head $tail) $predicate) (let $tail-result (filter' $tail $predicate) (if ($predicate $head) (Cons $head $tail-result) $tail-result)))
(= (map-pairs $list1 $list2 $fn) (map-atom $list1 $v1 (map-atom $list2 $v2 ($fn $v1 $v2))))
(= (find_vars $stmt) (filter-atom $stmt $tok (unify &kb (Var $tok $_ (Type "$v")) True False)))
(: string< (-> String String Bool))
(= (string< $x $y) ((py-dot $x __lt__) $y))
(= (orient_pair $x $y) (let ($str_x $str_y) ((repr $x) (repr $y)) (if (string< $str_x $str_y) ($x $y) ($y $x))))
(= (lookup_d $x $y) (let ($x' $y') (orient_pair $x $y) (unify &kb (DVar ($x' $y') $_ (Type "$d")) True False)))
(= (dv_check $x $y) (if (or (== $x $y) (not (lookup_d $x $y))) (Error ($x $y) "Disjoint variable violation.") ()))
(= (check_dvs $subst $dvs0) (map-atom $dvs0 $d (let* ( (($d1 $d2) $d) ($x_vars (match $subst ($d1 $sub1) (find_vars $sub1))) ($y_vars (match $subst ($d2 $sub2) (find_vars $sub2))) ) (map-pairs $x_vars $y_vars dv_check))))
(= (add_c $tok) (unify &kb (Constant $tok (Type "$c")) (Error (Constant $tok) "Constant already declared.") (unify &kb (Var $tok $_ (Type "$v")) (Error (Var $tok) "Trying to declare as a constant an active variable.") (add-atom &kb ( Constant $tok (Type "$c") )))))
(= (add_v $tok $level) (unify &kb (Var $tok $_ (Type "$v")) (Error (Var $tok) "Var already declared and active.") (unify &kb (Constant $tok (Type "$c")) (Error (Constant $tok) "Var already declared as constant.") (add-atom &kb ( Var $tok (FSDepth $level) (Type "$v") )))))
(= (add_dv_pair_if_fresh $x $y $level) (if (== $x $y) () (let ($ox $oy) (orient_pair $x $y) (unify &kb (DVar ($ox $oy) (FSDepth $level) (Type "$d")) () (add-atom &kb (DVar ($ox $oy) (FSDepth $level) (Type "$d") ))))))
(= (add_d $varlist $level) (map-atom $varlist $x (map-atom $varlist $y (add_dv_pair_if_fresh $x $y $level))))
(= (add_f $label $typecode $var $level) (unify &kb (Var $var $_ (Type "$v")) (unify &kb (Constant $typecode (Type "$c")) (unify &kb ( (Label $label') FHyp (FSDepth $FSDepth) ( (Typecode $typecode') (FVar $var) (Type "$f") ) ) (Error ( (Label $label') (Typecode $typecode') (Var $var) ) "Var in $f already typed by an active $f-statement." ) (let* ( ($flist_entry (to-list (($typecode $var)))) (() (unify &kb (FList (FSDepth $level) $flist) (let $flist' (append $flist $flist_entry) (update-atom &kb (FList (FSDepth $level) $flist) (FList (FSDepth $level) $flist'))) (add-atom &kb (FList (FSDepth $level) $flist_entry)))) ) (add-atom &kb ( (Label $label) FHyp (FSDepth $level) ( (Typecode $typecode) (FVar $var) (Type "$f") ))) ) ) (Error (Constant $typecode) "Typecode in $f not declared.")) (Error (Var $var) "Var in $f not declared.")) )
(= (add_e $label $stmt $level) (let* ( ($elist_entry (to-list ($stmt))) (() (unify &kb (EList (FSDepth $level) $elist) (let $elist' (append $elist $elist_entry) (update-atom &kb (EList (FSDepth $level) $elist) (EList (FSDepth $level) $elist'))) (add-atom &kb (EList (FSDepth $level) $elist_entry)))) (() (println! ("add essential hypothesis:" (label $label) (Statement $stmt) (level $level)))) ) (add-atom &kb ( (Label $label) EHyp (FSDepth $level) ( (Statement $stmt) (Type "$e") ))) ) )
(= (collect_lists_by_depth $unordered_list $current $max $ordered_list) (if (> $current $max) $ordered_list (let $current_list (match-atom'' $unordered_list ($current $list) $list Nil) (let () (println! ("collect list:" $current - $current_list)) (collect_lists_by_depth $unordered_list (+ 1 $current) $max (append $ordered_list $current_list))))))
(= (add_mand_var $tok) (unify &kb (Var $tok $_ (Type "$v")) (unify &kb (MandVar $tok) () (add-atom &kb (MandVar $tok))) ()))
(= (assign_f_hyp_to_var $f_hyp) (let ($typecode $var) $f_hyp (unify &kb (MandVar $var) (let () (remove-atom &kb (MandVar $var)) True) False)))
(= (assign_f_hyps Nil) Nil)
(= (assign_f_hyps (Cons $head $tail)) (let* ( ($tail-result (assign_f_hyps $tail)) (($typecode $var) $head) ($pred (unify &kb (MandVar $var) True False)) ) (if (== $pred True) (let () (remove-atom &kb (MandVar $var)) (Cons $head $tail-result)) $tail-result)))
(= (make_assertion $stmt) (let* ( ($e_hyps_lists (matchc &kb (EList (FSDepth $level) $elist) ($level $elist))) (() (println! ("e_hyps lists:" $e_hyps_lists))) ($e_levels (collapse (match-atom' $e_hyps_lists ($l $_) $l))) (() (println! ("e_levels:" $e_levels))) ($e_max_level (if (== $e_levels (())) 0 (max-atom $e_levels))) (() (println! ("max_level of ehyps frame stack:" $e_max_level))) ($e_hyps_list (collect_lists_by_depth $e_hyps_lists 1 $e_max_level Nil)) (() (println! ("e_hyps_list:" $e_hyps_list))) ($e_hyps_toks (from-list (flatten-list $e_hyps_list))) ($_0 (map-atom $e_hyps_toks $tok (add_mand_var $tok))) ($_1 (map-atom $stmt $tok (add_mand_var $tok))) ($mand_vars (matchc &kb (MandVar $var) $var)) (() (println! ("mand_vars:" $mand_vars))) ($dvs (matchc &kb (DVar ($x $y) $_ (Type "$d")) (unify &kb (MandVar $x) (unify &kb (MandVar $y) ($x $y) ()) ()))) (() (println! ("dvs:" $dvs))) ($f_hyps_lists (matchc &kb (FList (FSDepth $level) $flist) ($level $flist))) (() (println! ("f_hyps lists:" $f_hyps_lists))) ($f_levels (collapse (match-atom' $f_hyps_lists ($l $_) $l))) (() (println! ("f_levels:" $f_levels))) ($f_max_level (if (== $f_levels (())) 0 (max-atom $f_levels))) (() (println! ("max_level of fhyps frame stack:" $f_max_level))) ($f_hyps_list (collect_lists_by_depth $f_hyps_lists 1 $f_max_level Nil)) (() (println! ("f_hyps_list:" $f_hyps_list))) ($f_hyps (filter' $f_hyps_list assign_f_hyp_to_var)) (() (println! ("f_hyps:" $f_hyps))) ($mand_vars' (matchc &kb (MandVar $var) $var)) (() (println! ("mand_vars':" $mand_vars'))) ($_2 (remove-patternc &kb (MandVar $var))) ) ( (DVars $dvs) (FHyps (from-list $f_hyps)) (EHyps (from-list $e_hyps_list)) (Statement $stmt) )))
(= (add_a $label $stmt) (let* ( (() (println! ("make_assertion" $label - $stmt))) (( (DVars $dvs) (FHyps $f_hyps) (EHyps $e_hyps) (Statement $stmt) ) (make_assertion $stmt)) (() (println! ("gathered assertion data:" $dvs $f_hyps $e_hyps $stmt))) ) (add-atom &kb ( (Label $label) Assertion ( (DVars $dvs) (FHyps $f_hyps) (EHyps $e_hyps) (Statement $stmt) (Type "$a") )))))
(= (add-subst $subst ($typecode $var)) (let* ( ($sp (get-state &sp)) ($entry (match &stack ((Num $sp) $s) $s)) (($entry0 $entry1:) (decons-atom $entry)) ) (if (== $entry0 $typecode) (let* ( (() (println! ("adding subst" $var $entry1:))) (() (add-atom $subst ($var $entry1:))) ($_ (adjust-state-additive &sp 1)) ) ($var $entry1:)) (Error ( (sp $sp) (entry $entry) (typecode $typecode) (var $var) ) "Proof stack entry does not match floating hypothesis."))))
(= (apply_subst_tok $subst $tok) (let $res (unify $subst ($tok $sub) $sub $tok) $res))
(= (apply_subst $subst $stmt) (flatten-expr (map-atom $stmt $tok (apply_subst_tok $subst $tok))))
(= (check_subst $subst $ehyp) (let* ( ($sp (get-state &sp)) ($entry (match &stack ((Num $sp) $s) $s)) ($subst_h (apply_subst $subst $ehyp)) ) (if (== $entry $subst_h) (adjust-state-additive &sp 1) (Error ( (sp $sp) (entry $entry) (ehyp $ehyp) (subst_h $subst_h) ) "Proof stack entry does not match essential hypothesis."))))
(= (treat_assertion $label $Data $stack_len) (let* ( ($dvars (match-atom' $Data (DVars $dvars) $dvars )) ($fhyps (match-atom' $Data (FHyps $fhyps) $fhyps )) ($ehyps (match-atom' $Data (EHyps $ehyps) $ehyps )) ($statement (match-atom' $Data (Statement $statement) $statement )) ($lf (size-atom $fhyps)) ($le (size-atom $ehyps)) ($npop (+ $lf $le)) ($sp (- $stack_len $npop)) (() (println! (stack_len: $stack_len , npop: $npop , sp: $sp))) (() (if (< $sp 0) (Error ((label $label) (npop $npop)) "Stack underflow: proof step requires too many hypotheses") ())) ($_0 (change-state! &sp $sp)) ($subst (new-space)) ($_1 (map-atom $fhyps $fhyp (add-subst $subst $fhyp))) ($_2 (map-atom $ehyps $ehyp (check_subst $subst $ehyp))) ($_3 (eval (collapse (check_dvs $subst $dvars)))) ($_4 (matchc &stack ( (Num $n) $s ) (if (>= $n $sp) (remove-atom &stack ( (Num $n) $s )) ()))) ($new_conclusion (let $new_conclusion (apply_subst $subst $statement) (let () (add-atom &stack ((Num $sp) $new_conclusion)) $new_conclusion))) (() (println! (new_conclusion: $new_conclusion))) ) (println! (stack ($label): (matchc &stack $s $s)))))
(= (treat_hypothesis $label $Type $Data $stack_len) (unify &kb (ActiveHyp $label) (case $Type ( (FHyp (match-atom' $Data (Typecode $t) (match-atom' $Data (FVar $v) (add-atom &stack ((Num $stack_len) ($t $v)))))) (EHyp (match-atom' $Data (Statement $s) (add-atom &stack ((Num $stack_len) $s)))) )) (Error (label $label) "The label is the label of a nonactive hypothesis.")))
(= (treat_step $label) (let* ( (() (println! (»»» treating label $label))) (($Type $Data) (unify &kb ((Label $label) $Type $Data) ($Type $Data) (unify &kb ((Label $label) $Type (FSDepth $level) $Data) ($Type $Data) (Error (label $label) "No statement information found for label")))) ($stack_len (case (matchc &stack ( (Num $n) $s ) $n) ( ( () 0 ) ( $nums (+ 1 (max-atom $nums))) ))) (() (println! ($Type $label data: $Data))) ) (case $Type ( (FHyp (treat_hypothesis $label $Type $Data $stack_len)) (EHyp (treat_hypothesis $label $Type $Data $stack_len)) (Assertion (treat_assertion $label $Data $stack_len)) (Proof (treat_assertion $label $Data $stack_len)) )) ))
(= (treat_normal_proof $proof) (let* ( (() (println! (Got Proof: $proof))) ($_0 (empty-space &stack)) ($_1 (matchc &kb ((Label $label) FHyp $FSDepth $Data) (add-atom &kb (ActiveHyp $label)))) ($_2 (matchc &kb ((Label $label) EHyp $FSDepth $Data) (add-atom &kb (ActiveHyp $label)))) ($_3 (map-atom $proof $label (treat_step $label))) ) (remove-patternc &kb (ActiveHyp $_))))
(= (verify $proof $conclusion) (let* ( ($_0 (treat_normal_proof $proof)) ($stack_expr (matchc &stack ( (Num  $n) $f) $f)) (() (if (== () $stack_expr) (Error (assertion: $conclusion) "Empty stack at end of proof.") ())) (() (if (> (size-atom $stack_expr) 1) (Error ((assertion: $conclusion) (stack: $stack_expr)) "Stack has more than one entry at end of proof.") ())) ($stack_top (car-atom $stack_expr)) (() (println! (Comparing: $stack_top "==" $conclusion))) (() (if (== $conclusion $stack_top) () (Error ((assertion: $conclusion) (stack: $stack_expr)) "Stack entry does not match proved assertion."))) (() (println! "Correct proof!")) ) ()))
(= (add_p $label $stmt $proof $verify_proofs) (let* ( (() (println! "")) (() (println! (Verifying conclusion ($label) $stmt with proof $proof))) (() (if $verify_proofs (verify $proof $stmt) ())) (() (println! ("make_assertion" $label - $stmt))) (( (DVars $dvs) (FHyps $f_hyps) (EHyps $e_hyps) (Statement $stmt) ) (make_assertion $stmt)) (() (println! ("gathered assertion data:" $dvs $f_hyps $e_hyps $stmt))) ) (add-atom &kb ( (Label $label) Proof ( (DVars $dvs) (FHyps $f_hyps) (EHyps $e_hyps) (Statement $stmt) (Type "$p") (ProofSequence $proof) )))))
!(add_c "formula")
!(add_c "|-")
!(add_c "(")
!(add_c ")")
!(add_v "x" 1)
!(add_v "y" 1)
!(add_v "z" 1)
!(add_v "w" 1)
!(add_f "xf" "formula" "x" 1)
!(add_f "yf" "formula" "y" 1)
!(add_f "zf" "formula" "z" 1)
!(add_f "wf" "formula" "w" 1)
!(add_a "combo" ("formula" "(" "x" "y" ")"))
!(add_d ("x" "y") 2)
!(add_a "ax-1" ("|-" "(" "x" "y" ")"))
!(remove-pattern &kb (EList (FSDepth 2) $elist))
!(remove-pattern &kb (FList (FSDepth 2) $flist))
!(remove-pattern &kb ($1 $2 (FSDepth 2) $Data))
!(add_d ("x" "y" "z" "w") 2)
!(add_p "good" ("|-" "(" "(" "x" "y" ")" "(" "z" "w" ")" ")") ("xf" "yf" "combo" "zf" "wf" "combo" "ax-1") True)
!(remove-pattern &kb (EList (FSDepth 2) $elist))
!(remove-pattern &kb (FList (FSDepth 2) $flist))
!(remove-pattern &kb ($1 $2 (FSDepth 2) $Data))
!(add_d ("x" "z") 2)
!(add_d ("x" "w") 2)
!(add_d ("y" "z") 2)
!(add_d ("y" "w") 2)
!(add_p "stillgood" ("|-" "(" "(" "x" "y" ")" "(" "z" "w" ")" ")") ("xf" "yf" "combo" "zf" "wf" "combo" "ax-1") True)
!(remove-pattern &kb (EList (FSDepth 2) $elist))
!(remove-pattern &kb (FList (FSDepth 2) $flist))
!(remove-pattern &kb ($1 $2 (FSDepth 2) $Data))
!(remove-pattern &kb (EList (FSDepth 1) $elist))
!(remove-pattern &kb (FList (FSDepth 1) $flist))
!(remove-pattern &kb ($1 $2 (FSDepth 1) $Data))
