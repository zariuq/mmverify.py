!(bind! &stack (new-space))
!(bind! &frames (new-space))
!(bind! &wm (new-space))
(: matchc (-> hyperon::space::DynSpace Atom Atom %Undefined%))
(= (matchc $space $pattern $query) (collapse (match $space $pattern $query)))
(= (empty-space $space) (matchc $space $atom (remove-atom $space $atom)))
(= (remove-pattern $space $pattern) (matchc $space $pattern (remove-atom $space $pattern)))
(= (remove_from_stack $stack_ptr $stack_len) (if (> $stack_len $stack_ptr) (let () (match &stack ( (Num $stack_ptr) $s ) (remove-atom &stack ( (Num $stack_ptr) $s ))) (remove_from_stack (+ 1 $stack_ptr) $stack_len)) ()))
(: match-atom (-> Expression Atom Atom %Undefined$))
(= (match-atom $expr $pattern $rewrite) (if-decons-expr $expr $head $tail (let $pattern $head $rewrite) (empty)))
(= (match-atom $expr $pattern $rewrite) (if-decons-expr $expr $head $tail (match-atom $tail $pattern $rewrite) (empty)))
(: match-atom' (-> Expression Atom Atom %Undefined$))
(= (match-atom' $expr $pattern $rewrite) (case (match-atom $expr $pattern $rewrite) ( (Empty () ) ( $q $q ) )))
(= (update-atom $space $atom $update_pattern) (match $space $atom (let () (add-atom $space $update_pattern) (remove-atom $space $atom))))
(= (add-subst $subst ($typecode $var)) (let* ( ($sp (match &wm (sp $sp) $sp)) ($entry (match &stack ((Num $sp) $s) $s)) (($entry0 $entry1:) (decons-atom $entry)) ) (if (== $entry0 $typecode) (let* ( (() (println! ("adding subst" $var $entry1:))) (() (add-atom $subst ($var $entry1:))) (() (update-atom &wm (sp $n) (sp (+ $n 1)))) ) ($var $entry1:)) (Error ( (sp $sp) (entry $entry) (typecode $typecode) (var $var) ) "Proof stack entry does not match floating hypothesis."))))
(= (to-list $expr) (if (== $expr ()) Nil (Cons (car-atom $expr) (to-list (cdr-atom $expr)))))
(= (to-list' $expr $tail) (if (== $expr ()) $tail (Cons (car-atom $expr) (to-list' (cdr-atom $expr) $tail))))
(= (flatten-list Nil) Nil)
(= (flatten-list (Cons $head $tail)) (case (get-metatype $head) ((Expression (to-list' $head (flatten-list $tail))) ($_ (Cons $head (flatten-list $tail))))))
(= (from-list Nil) ())
(= (from-list (Cons $head $tail)) (let $tail-list (from-list $tail) (cons-atom $head $tail-list)))
(= (flatten-expr $expr) (from-list (flatten-list (to-list $expr))))
(= (apply_subst_tok $subst $tok) (let $res (unify $subst ($tok $sub) $sub $tok) $res))
(= (apply_subst $subst $stmt) (flatten-expr (map-atom $stmt $tok (apply_subst_tok $subst $tok))))
(= (check_subst $subst $ehyp) (let* ( ($sp (match &wm (sp $sp) $sp)) ($entry (match &stack ((Num $sp) $s) $s)) ($subst_h (apply_subst $subst $ehyp)) ) (if (== $entry $subst_h) (update-atom &wm (sp $n) (sp (+ $n 1))) (Error ( (sp $sp) (entry $entry) (ehyp $ehyp) (subst_h $subst_h) ) "Proof stack entry does not match essential hypothesis."))))
(= (map-pairs $list1 $list2 $fn) (map-atom $list1 $v1 (map-atom $list2 $v2 ($fn $v1 $v2))))
(= (find_vars $stmt) (filter-atom $stmt $tok (unify &frames (Var $tok $_) True False)))
(= (orient_pair $x $y) (((py-atom min) $x $y) ((py-atom max) $x $y)))
(= (lookup_d $x $y) (let ($x' $y') (orient_pair $x $y) (unify &frames (DVar ($x' $y') $_) True False)))
(= (dv_check $x $y) (if (or (== $x $y) (not (lookup_d $x $y))) (Error ($x $y) "Disjoint variable violation.") ()))
(= (check_dvs $subst $dvs0) (map-atom $dvs0 $d (let ($d1 $d2) $d (let ($x_vars $y_vars) (match $subst ($d1 $sub1) (match $subst ($d2 $sub2) ((find_vars $sub1) (find_vars $sub2)))) (map-pairs $x_vars $y_vars dv_check)))))
(= (treat_assertion $label $Data $stack_len) (let* ( ($dvars (match-atom' $Data (DVars $dvars) $dvars )) ($fhyps (match-atom' $Data (FHyps $fhyps) $fhyps )) ($ehyps (match-atom' $Data (EHyps $ehyps) $ehyps )) ($statement (match-atom' $Data (Statement $statement) $statement )) ($lf (size-atom $fhyps)) ($le (size-atom $ehyps)) ($npop (+ $lf $le)) ($sp (- $stack_len $npop)) (() (println! (stack_len: $stack_len , npop: $npop , sp: $sp))) (() (if (< $sp 0) (Error ((label $label) (npop $npop)) "Stack underflow: proof step requires too many hypotheses") ())) (() (add-atom &wm (sp $sp))) ($subst (new-space)) ($_0 (map-atom $fhyps $fhyp (add-subst $subst $fhyp))) ($_1 (map-atom $ehyps $ehyp (check_subst $subst $ehyp))) ($_2 (check_dvs $subst $dvars)) ($_3 (matchc &stack ( (Num $n) $s ) (if (>= $n $sp) (remove-atom &stack ( (Num $n) $s )) ()))) ($new_conclusion (let $new_conclusion (apply_subst $subst $statement) (let () (add-atom &stack ((Num $sp) $new_conclusion)) $new_conclusion))) (() (println! (new_conclusion: $new_conclusion))) ($_4 (empty-space &wm)) ) (println! (stack ($label): (matchc &stack $s $s)))))
(= (treat_hypothesis $label $Type $Data $stack_len) (unify &frames (ActiveHyp $label) (case $Type ( (FHyp (match-atom' $Data (Typecode $t) (match-atom' $Data (FVar $v) (add-atom &stack ((Num $stack_len) ($t $v)))))) (EHyp (match-atom' $Data (Statement $s) (add-atom &stack ((Num $stack_len) $s)))) )) (Error (label $label) "The label is the label of a nonactive hypothesis.")))
(= (treat_step $label) (let* ( (() (println! (»»» treating label $label))) (($Type $Data) (unify &frames ((Label $label) $Type $Data) ($Type $Data) (Error (label $label) "No statement information found for label"))) ($stack_len (case (matchc &stack ( (Num $n) $s ) $n) ( ( () 0 ) ( $nums (+ 1 (max-atom $nums))) ))) (() (println! ($label data: $Data))) ) (case $Type ( (FHyp (treat_hypothesis $label $Type $Data $stack_len)) (EHyp (treat_hypothesis $label $Type $Data $stack_len)) (Assertion (treat_assertion $label $Data $stack_len)) (Proof (treat_assertion $label $Data $stack_len)) )) ))
(= (treat_normal_proof $proof) (let* ( (() (println! (Got Proof: $proof))) ($_0 (empty-space &stack)) ($_1 (matchc &frames ((Label $label) FHyp $Data) (add-atom &frames (ActiveHyp $label)))) ($_2 (matchc &frames ((Label $label) EHyp $Data) (add-atom &frames (ActiveHyp $label)))) ($_3 (map-atom $proof $label (treat_step $label))) ) (remove-pattern &frames (ActiveHyp $_))))
(= (verify $proof $conclusion) (let* ( (() (println! (Verifying conclusion $conclusion of proof $proof))) ($_0 (treat_normal_proof $proof)) ($stack_expr (matchc &stack ( (Num  $n) $f) $f)) (() (if (== () $stack_expr) (Error (assertion: $conclusion) "Empty stack at end of proof.") ())) (() (if (> (size-atom $stack_expr) 1) (Error ((assertion: $conclusion) (stack: $stack_expr)) "Stack has more than one entry at end of proof.") ())) ($stack_top (car-atom $stack_expr)) (() (println! (Comparing: $stack_top "==" $conclusion))) (() (if (== $conclusion $stack_top) () (Error ((assertion: $conclusion) (stack: $stack_expr)) "Stack entry does not match proved assertion."))) (() (println! "Correct proof!")) ($_1 (empty-space &stack)) ) ($stack_top)))
 !(add-atom &frames ( Constant "var" (Type "$c") ))
 !(add-atom &frames ( Constant "type" (Type "$c") ))
 !(add-atom &frames ( Constant "term" (Type "$c") ))
 !(add-atom &frames ( Constant "|-" (Type "$c") ))
 !(add-atom &frames ( Constant ":" (Type "$c") ))
 !(add-atom &frames ( Constant "." (Type "$c") ))
 !(add-atom &frames ( Constant "|=" (Type "$c") ))
 !(add-atom &frames ( Constant "bool" (Type "$c") ))
 !(add-atom &frames ( Constant "ind" (Type "$c") ))
 !(add-atom &frames ( Constant "->" (Type "$c") ))
 !(add-atom &frames ( Constant "(" (Type "$c") ))
 !(add-atom &frames ( Constant ")" (Type "$c") ))
 !(add-atom &frames ( Constant "," (Type "$c") ))
 !(add-atom &frames ( Constant "\\" (Type "$c") ))
 !(add-atom &frames ( Constant "=" (Type "$c") ))
 !(add-atom &frames ( Constant "T." (Type "$c") ))
 !(add-atom &frames ( Constant "[" (Type "$c") ))
 !(add-atom &frames ( Constant "]" (Type "$c") ))
!(add-atom &frames ( Var "al" ( (FSDepth 1) (Type "$v") )))
!(add-atom &frames ( Var "be" ( (FSDepth 1) (Type "$v") )))
!(add-atom &frames ( Var "ga" ( (FSDepth 1) (Type "$v") )))
!(add-atom &frames ( Var "de" ( (FSDepth 1) (Type "$v") )))
!(add-atom &frames ( Var "x" ( (FSDepth 1) (Type "$v") )))
!(add-atom &frames ( Var "y" ( (FSDepth 1) (Type "$v") )))
!(add-atom &frames ( Var "z" ( (FSDepth 1) (Type "$v") )))
!(add-atom &frames ( Var "f" ( (FSDepth 1) (Type "$v") )))
!(add-atom &frames ( Var "g" ( (FSDepth 1) (Type "$v") )))
!(add-atom &frames ( Var "p" ( (FSDepth 1) (Type "$v") )))
!(add-atom &frames ( Var "q" ( (FSDepth 1) (Type "$v") )))
!(add-atom &frames ( Var "A" ( (FSDepth 1) (Type "$v") )))
!(add-atom &frames ( Var "B" ( (FSDepth 1) (Type "$v") )))
!(add-atom &frames ( Var "C" ( (FSDepth 1) (Type "$v") )))
!(add-atom &frames ( Var "F" ( (FSDepth 1) (Type "$v") )))
!(add-atom &frames ( Var "R" ( (FSDepth 1) (Type "$v") )))
!(add-atom &frames ( Var "S" ( (FSDepth 1) (Type "$v") )))
!(add-atom &frames ( Var "T" ( (FSDepth 1) (Type "$v") )))
!(add-atom &frames ( (Label "hal") FHyp ( (FSDepth 1) (Typecode "type") (FVar "al") (Type "$f") )))
!(add-atom &frames ( (Label "hbe") FHyp ( (FSDepth 1) (Typecode "type") (FVar "be") (Type "$f") )))
!(add-atom &frames ( (Label "hga") FHyp ( (FSDepth 1) (Typecode "type") (FVar "ga") (Type "$f") )))
!(add-atom &frames ( (Label "hde") FHyp ( (FSDepth 1) (Typecode "type") (FVar "de") (Type "$f") )))
!(add-atom &frames ( (Label "vx") FHyp ( (FSDepth 1) (Typecode "var") (FVar "x") (Type "$f") )))
!(add-atom &frames ( (Label "vy") FHyp ( (FSDepth 1) (Typecode "var") (FVar "y") (Type "$f") )))
!(add-atom &frames ( (Label "vz") FHyp ( (FSDepth 1) (Typecode "var") (FVar "z") (Type "$f") )))
!(add-atom &frames ( (Label "vf") FHyp ( (FSDepth 1) (Typecode "var") (FVar "f") (Type "$f") )))
!(add-atom &frames ( (Label "vg") FHyp ( (FSDepth 1) (Typecode "var") (FVar "g") (Type "$f") )))
!(add-atom &frames ( (Label "vp") FHyp ( (FSDepth 1) (Typecode "var") (FVar "p") (Type "$f") )))
!(add-atom &frames ( (Label "vq") FHyp ( (FSDepth 1) (Typecode "var") (FVar "q") (Type "$f") )))
!(add-atom &frames ( (Label "ta") FHyp ( (FSDepth 1) (Typecode "term") (FVar "A") (Type "$f") )))
!(add-atom &frames ( (Label "tb") FHyp ( (FSDepth 1) (Typecode "term") (FVar "B") (Type "$f") )))
!(add-atom &frames ( (Label "tc") FHyp ( (FSDepth 1) (Typecode "term") (FVar "C") (Type "$f") )))
!(add-atom &frames ( (Label "tf") FHyp ( (FSDepth 1) (Typecode "term") (FVar "F") (Type "$f") )))
!(add-atom &frames ( (Label "tr") FHyp ( (FSDepth 1) (Typecode "term") (FVar "R") (Type "$f") )))
!(add-atom &frames ( (Label "ts") FHyp ( (FSDepth 1) (Typecode "term") (FVar "S") (Type "$f") )))
!(add-atom &frames ( (Label "tt") FHyp ( (FSDepth 1) (Typecode "term") (FVar "T") (Type "$f") )))
!(add-atom &frames ( (Label "tv") Assertion ( (DVars ()) (FHyps (("type" "al") ("var" "x"))) (EHyps ()) (Statement ("term" "x" ":" "al")) (Type "$a") )))
!(add-atom &frames ( (Label "ht") Assertion ( (DVars ()) (FHyps (("type" "al") ("type" "be"))) (EHyps ()) (Statement ("type" "(" "al" "->" "be" ")")) (Type "$a") )))
!(add-atom &frames ( (Label "hb") Assertion ( (DVars ()) (FHyps ()) (EHyps ()) (Statement ("type" "bool")) (Type "$a") )))
!(add-atom &frames ( (Label "hi") Assertion ( (DVars ()) (FHyps ()) (EHyps ()) (Statement ("type" "ind")) (Type "$a") )))
!(add-atom &frames ( (Label "kc") Assertion ( (DVars ()) (FHyps (("term" "F") ("term" "T"))) (EHyps ()) (Statement ("term" "(" "F" "T" ")")) (Type "$a") )))
!(add-atom &frames ( (Label "kl") Assertion ( (DVars ()) (FHyps (("type" "al") ("var" "x") ("term" "T"))) (EHyps ()) (Statement ("term" "\\" "x" ":" "al" "." "T")) (Type "$a") )))
!(add-atom &frames ( (Label "ke") Assertion ( (DVars ()) (FHyps ()) (EHyps ()) (Statement ("term" "=")) (Type "$a") )))
!(add-atom &frames ( (Label "kt") Assertion ( (DVars ()) (FHyps ()) (EHyps ()) (Statement ("term" "T.")) (Type "$a") )))
!(add-atom &frames ( (Label "kbr") Assertion ( (DVars ()) (FHyps (("term" "A") ("term" "B") ("term" "F"))) (EHyps ()) (Statement ("term" "[" "A" "F" "B" "]")) (Type "$a") )))
!(add-atom &frames ( (Label "kct") Assertion ( (DVars ()) (FHyps (("term" "A") ("term" "B"))) (EHyps ()) (Statement ("term" "(" "A" "," "B" ")")) (Type "$a") )))
 !(add-atom &frames ( Constant "wff" (Type "$c") ))
!(add-atom &frames ( (Label "wffMMJ2") Assertion ( (DVars ()) (FHyps (("term" "A") ("term" "B"))) (EHyps ()) (Statement ("wff" "A" "|=" "B")) (Type "$a") )))
!(add-atom &frames ( (Label "wffMMJ2t") Assertion ( (DVars ()) (FHyps (("type" "al") ("term" "A"))) (EHyps ()) (Statement ("wff" "A" ":" "al")) (Type "$a") )))
!(add-atom &frames ( (Label "idi.1") EHyp ( (FSDepth 2) (ENum 1) (Statement ("|-" "R" "|=" "A")) (Type "$e") )))
!(verify ("idi.1") ("|-" "R" "|=" "A"))
!(add-atom &frames ( (Label "idi") Proof ( (DVars ()) (FHyps (("term" "A") ("term" "R"))) (EHyps (("|-" "R" "|=" "A"))) (Statement ("|-" "R" "|=" "A")) (Type "$p") (ProofSequence ("idi.1")))))
!(match &frames ($1 $2 $Data) (match-atom $Data (FSDepth 2) (remove-atom &frames ($1 $2 $Data))))
!(add-atom &frames ( (Label "idt.1") EHyp ( (FSDepth 2) (ENum 1) (Statement ("|-" "A" ":" "al")) (Type "$e") )))
!(verify ("idt.1") ("|-" "A" ":" "al"))
!(add-atom &frames ( (Label "idt") Proof ( (DVars ()) (FHyps (("type" "al") ("term" "A"))) (EHyps (("|-" "A" ":" "al"))) (Statement ("|-" "A" ":" "al")) (Type "$p") (ProofSequence ("idt.1")))))
!(match &frames ($1 $2 $Data) (match-atom $Data (FSDepth 2) (remove-atom &frames ($1 $2 $Data))))
!(add-atom &frames ( (Label "ax-syl.1") EHyp ( (FSDepth 2) (ENum 1) (Statement ("|-" "R" "|=" "S")) (Type "$e") )))
!(add-atom &frames ( (Label "ax-syl.2") EHyp ( (FSDepth 2) (ENum 2) (Statement ("|-" "S" "|=" "T")) (Type "$e") )))
!(add-atom &frames ( (Label "ax-syl") Assertion ( (DVars ()) (FHyps (("term" "R") ("term" "S") ("term" "T"))) (EHyps (("|-" "R" "|=" "S") ("|-" "S" "|=" "T"))) (Statement ("|-" "R" "|=" "T")) (Type "$a") )))
!(verify ("tr" "ts" "tt" "ax-syl.1" "ax-syl.2" "ax-syl") ("|-" "R" "|=" "T"))
!(add-atom &frames ( (Label "syl") Proof ( (DVars ()) (FHyps (("term" "R") ("term" "S") ("term" "T"))) (EHyps (("|-" "R" "|=" "S") ("|-" "S" "|=" "T"))) (Statement ("|-" "R" "|=" "T")) (Type "$p") (ProofSequence ("tr" "ts" "tt" "ax-syl.1" "ax-syl.2" "ax-syl")))))
!(match &frames ($1 $2 $Data) (match-atom $Data (FSDepth 2) (remove-atom &frames ($1 $2 $Data))))
!(add-atom &frames ( (Label "ax-jca.1") EHyp ( (FSDepth 2) (ENum 1) (Statement ("|-" "R" "|=" "S")) (Type "$e") )))
!(add-atom &frames ( (Label "ax-jca.2") EHyp ( (FSDepth 2) (ENum 2) (Statement ("|-" "R" "|=" "T")) (Type "$e") )))
!(add-atom &frames ( (Label "ax-jca") Assertion ( (DVars ()) (FHyps (("term" "R") ("term" "S") ("term" "T"))) (EHyps (("|-" "R" "|=" "S") ("|-" "R" "|=" "T"))) (Statement ("|-" "R" "|=" "(" "S" "," "T" ")")) (Type "$a") )))
!(verify ("tr" "ts" "tt" "ax-jca.1" "ax-jca.2" "ax-jca") ("|-" "R" "|=" "(" "S" "," "T" ")"))
!(add-atom &frames ( (Label "jca") Proof ( (DVars ()) (FHyps (("term" "R") ("term" "S") ("term" "T"))) (EHyps (("|-" "R" "|=" "S") ("|-" "R" "|=" "T"))) (Statement ("|-" "R" "|=" "(" "S" "," "T" ")")) (Type "$p") (ProofSequence ("tr" "ts" "tt" "ax-jca.1" "ax-jca.2" "ax-jca")))))
!(match &frames ($1 $2 $Data) (match-atom $Data (FSDepth 2) (remove-atom &frames ($1 $2 $Data))))
!(add-atom &frames ( (Label "syl2anc.1") EHyp ( (FSDepth 2) (ENum 1) (Statement ("|-" "R" "|=" "S")) (Type "$e") )))
!(add-atom &frames ( (Label "syl2anc.2") EHyp ( (FSDepth 2) (ENum 2) (Statement ("|-" "R" "|=" "T")) (Type "$e") )))
!(add-atom &frames ( (Label "syl2anc.3") EHyp ( (FSDepth 2) (ENum 3) (Statement ("|-" "(" "S" "," "T" ")" "|=" "A")) (Type "$e") )))
!(verify ("tr" "ts" "tt" "kct" "ta" "tr" "ts" "tt" "syl2anc.1" "syl2anc.2" "jca" "syl2anc.3" "syl") ("|-" "R" "|=" "A"))
!(add-atom &frames ( (Label "syl2anc") Proof ( (DVars ()) (FHyps (("term" "A") ("term" "R") ("term" "S") ("term" "T"))) (EHyps (("|-" "R" "|=" "S") ("|-" "R" "|=" "T") ("|-" "(" "S" "," "T" ")" "|=" "A"))) (Statement ("|-" "R" "|=" "A")) (Type "$p") (ProofSequence ("tr" "ts" "tt" "kct" "ta" "tr" "ts" "tt" "syl2anc.1" "syl2anc.2" "jca" "syl2anc.3" "syl")))))
!(match &frames ($1 $2 $Data) (match-atom $Data (FSDepth 2) (remove-atom &frames ($1 $2 $Data))))
!(match &frames ($1 $2 $Data) (match-atom $Data (FSDepth 1) (remove-atom &frames ($1 $2 $Data))))
